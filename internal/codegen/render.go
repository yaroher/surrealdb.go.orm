package codegen

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
)

func Render(dir string, pkg Package) error {
	out, err := RenderToBytes(pkg)
	if err != nil {
		return err
	}
	path := outFileName(dir)
	return os.WriteFile(path, out, 0o644)
}

func RenderToBytes(pkg Package) ([]byte, error) {
	sort.Slice(pkg.Models, func(i, j int) bool { return pkg.Models[i].Name < pkg.Models[j].Name })

	var buf bytes.Buffer
	buf.WriteString("// Code generated by surreal-orm-gen. DO NOT EDIT.\n\n")
	buf.WriteString("package ")
	buf.WriteString(pkg.Name)
	buf.WriteString("\n\n")
	renderImports(&buf, pkg.Imports)

	for _, model := range pkg.Models {
		renderModel(&buf, model)
	}
	renderResources(&buf, pkg.Models)

	return buf.Bytes(), nil
}

func renderImports(buf *bytes.Buffer, imports map[string]string) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"github.com/yaroher/surrealdb.go.orm/pkg/qb\"\n")
	buf.WriteString("\t\"github.com/yaroher/surrealdb.go.orm/pkg/migrator\"\n")

	var keys []string
	for name := range imports {
		if name == "_" || name == "." {
			continue
		}
		keys = append(keys, name)
	}
	sort.Strings(keys)

	for _, name := range keys {
		path := imports[name]
		if name == pathBase(path) {
			buf.WriteString("\t\"")
			buf.WriteString(path)
			buf.WriteString("\"\n")
			continue
		}
		buf.WriteString("\t")
		buf.WriteString(name)
		buf.WriteString(" \"")
		buf.WriteString(path)
		buf.WriteString("\"\n")
	}
	buf.WriteString(")\n\n")
}

func renderModel(buf *bytes.Buffer, model Model) {
	schemaName := fmt.Sprintf("%sSchema", model.Name)
	recv := receiverName(model.Name)
	buf.WriteString("type ")
	buf.WriteString(schemaName)
	buf.WriteString(" struct {\n")
	for _, field := range model.Fields {
		buf.WriteString("\t")
		buf.WriteString(field.Name)
		buf.WriteString(" qb.Field[")
		buf.WriteString(field.Type)
		buf.WriteString("]\n")
	}
	buf.WriteString("}\n\n")

	buf.WriteString("func (")
	buf.WriteString(recv)
	buf.WriteString(" ")
	buf.WriteString(model.Name)
	buf.WriteString(") Table() qb.Table {\n")
	buf.WriteString("\treturn qb.T(\"")
	buf.WriteString(model.Table)
	buf.WriteString("\")\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func (")
	buf.WriteString(recv)
	buf.WriteString(" ")
	buf.WriteString(model.Name)
	buf.WriteString(") Schema() ")
	buf.WriteString(schemaName)
	buf.WriteString(" {\n")
	buf.WriteString("\treturn ")
	buf.WriteString(schemaName)
	buf.WriteString("{\n")
	for _, field := range model.Fields {
		buf.WriteString("\t\t")
		buf.WriteString(field.Name)
		buf.WriteString(": qb.F[")
		buf.WriteString(field.Type)
		buf.WriteString("](\"")
		buf.WriteString(field.DBName)
		buf.WriteString("\"),\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n\n")

	if model.Kind == "edge" {
		buf.WriteString("func (")
		buf.WriteString(recv)
		buf.WriteString(" ")
		buf.WriteString(model.Name)
		buf.WriteString(") EdgeIn() qb.Table {\n")
		buf.WriteString("\treturn qb.T(\"")
		buf.WriteString(model.EdgeIn)
		buf.WriteString("\")\n")
		buf.WriteString("}\n\n")

		buf.WriteString("func (")
		buf.WriteString(recv)
		buf.WriteString(" ")
		buf.WriteString(model.Name)
		buf.WriteString(") EdgeOut() qb.Table {\n")
		buf.WriteString("\treturn qb.T(\"")
		buf.WriteString(model.EdgeOut)
		buf.WriteString("\")\n")
		buf.WriteString("}\n\n")
	}
}

func receiverName(typeName string) string {
	if typeName == "" {
		return "m"
	}
	return strings.ToLower(typeName[:1])
}

func pathBase(path string) string {
	if path == "" {
		return path
	}
	parts := strings.Split(path, "/")
	return parts[len(parts)-1]
}

func renderResources(buf *bytes.Buffer, models []Model) {
	buf.WriteString("func Resources() migrator.ResourceSet {\n")
	buf.WriteString("\tres := migrator.NewResourceSet()\n")
	for _, model := range models {
		if model.Kind == "access" && model.Access.Name != "" {
			renderAccessResource(buf, model.Access)
			continue
		}
		renderTableResources(buf, model)
	}
	buf.WriteString("\treturn res\n")
	buf.WriteString("}\n\n")
}

func renderTableResources(buf *bytes.Buffer, model Model) {
	buf.WriteString("\tres.AddTable(\"")
	buf.WriteString(model.Table)
	buf.WriteString("\", ")
	buf.WriteString("qb.DefineTableName(\"")
	buf.WriteString(model.Table)
	buf.WriteString("\")")
	if model.Drop {
		buf.WriteString(".DropTable()")
	}
	if model.SchemaFull {
		buf.WriteString(".SchemaFull()")
	}
	if model.SchemaLess {
		buf.WriteString(".SchemaLess()")
	}
	if model.Permissions != "" {
		writePermissions(buf, model.Permissions)
	}
	buf.WriteString(")\n")

	for _, field := range model.Fields {
		renderFieldResource(buf, model, field)
	}

	if model.Kind == "edge" && model.EdgeIn != "" && model.EdgeOut != "" {
		buf.WriteString("\tres.AddField(\"")
		buf.WriteString(model.Table)
		buf.WriteString("\", \"in\", ")
		buf.WriteString("qb.DefineFieldName(\"in\", \"")
		buf.WriteString(model.Table)
		buf.WriteString("\").Type(\"record<")
		buf.WriteString(model.EdgeIn)
		buf.WriteString(">\")")
		buf.WriteString(")\n")

		buf.WriteString("\tres.AddField(\"")
		buf.WriteString(model.Table)
		buf.WriteString("\", \"out\", ")
		buf.WriteString("qb.DefineFieldName(\"out\", \"")
		buf.WriteString(model.Table)
		buf.WriteString("\").Type(\"record<")
		buf.WriteString(model.EdgeOut)
		buf.WriteString(">\")")
		buf.WriteString(")\n")
	}
}

func renderAccessResource(buf *bytes.Buffer, ac AccessConfig) {
	if ac.Name == "" {
		return
	}
	buf.WriteString("\tres.AddAccess(\"")
	buf.WriteString(ac.Name)
	buf.WriteString("\", \"")
	buf.WriteString(ac.Scope)
	buf.WriteString("\", ")
	buf.WriteString("qb.DefineAccess(\"")
	buf.WriteString(ac.Name)
	buf.WriteString("\")")
	if ac.Overwrite {
		buf.WriteString(".Overwrite()")
	} else if ac.IfNotExists {
		buf.WriteString(".IfNotExists()")
	}
	switch strings.ToLower(ac.Scope) {
	case "namespace":
		buf.WriteString(".OnNamespace()")
	case "database":
		buf.WriteString(".OnDatabase()")
	}
	switch strings.ToLower(ac.Type) {
	case "jwt":
		buf.WriteString(".TypeJWT()")
		if ac.URL != "" {
			buf.WriteString(".JWTURL(")
			buf.WriteString(strconv.Quote(ac.URL))
			buf.WriteString(")")
		} else if ac.Algorithm != "" && ac.Key != "" {
			buf.WriteString(".JWTAlgorithmKey(\"")
			buf.WriteString(ac.Algorithm)
			buf.WriteString("\", ")
			buf.WriteString(strconv.Quote(ac.Key))
			buf.WriteString(")")
		}
	case "record":
		buf.WriteString(".TypeRecord()")
		if ac.RecordSignup != "" {
			buf.WriteString(".Signup(qb.Raw(")
			buf.WriteString(strconv.Quote(ac.RecordSignup))
			buf.WriteString("))")
		}
		if ac.RecordSignin != "" {
			buf.WriteString(".Signin(qb.Raw(")
			buf.WriteString(strconv.Quote(ac.RecordSignin))
			buf.WriteString("))")
		}
		if ac.RecordIssuer != "" {
			buf.WriteString(".RecordIssuerKey(")
			buf.WriteString(strconv.Quote(ac.RecordIssuer))
			buf.WriteString(")")
		}
		if ac.URL != "" {
			buf.WriteString(".RecordJWTURL(")
			buf.WriteString(strconv.Quote(ac.URL))
			buf.WriteString(")")
		} else if ac.Algorithm != "" && ac.Key != "" {
			buf.WriteString(".RecordJWTAlgorithmKey(\"")
			buf.WriteString(ac.Algorithm)
			buf.WriteString("\", ")
			buf.WriteString(strconv.Quote(ac.Key))
			buf.WriteString(")")
		}
		if ac.RecordRefresh {
			buf.WriteString(".WithRefresh()")
		}
	case "bearer":
		buf.WriteString(".TypeBearer()")
		if strings.ToLower(ac.Algorithm) == "record" {
			buf.WriteString(".BearerForRecord()")
		} else if strings.ToLower(ac.Algorithm) == "user" {
			buf.WriteString(".BearerForUser()")
		}
	}
	if ac.Authenticate != "" {
		buf.WriteString(".Authenticate(qb.Raw(")
		buf.WriteString(strconv.Quote(ac.Authenticate))
		buf.WriteString("))")
	}
	if ac.DurationGrant != "" {
		buf.WriteString(".DurationGrant(qb.Raw(")
		buf.WriteString(strconv.Quote(ac.DurationGrant))
		buf.WriteString("))")
	}
	if ac.DurationToken != "" {
		buf.WriteString(".DurationToken(qb.Raw(")
		buf.WriteString(strconv.Quote(ac.DurationToken))
		buf.WriteString("))")
	}
	if ac.DurationSession != "" {
		buf.WriteString(".DurationSession(qb.Raw(")
		buf.WriteString(strconv.Quote(ac.DurationSession))
		buf.WriteString("))")
	}
	buf.WriteString(")\n")

	if ac.GrantSubject != "" || ac.GrantToken != "" || ac.GrantDuration != "" {
		buf.WriteString("\tres.AddAccessGrant(\"")
		buf.WriteString(ac.Name)
		buf.WriteString("\", ")
		buf.WriteString("qb.AccessGrant(\"")
		buf.WriteString(ac.Name)
		buf.WriteString("\")")
		switch strings.ToLower(ac.Scope) {
		case "namespace":
			buf.WriteString(".OnNamespace()")
		case "database":
			buf.WriteString(".OnDatabase()")
		}
		if ac.GrantSubject != "" {
			buf.WriteString(".Subject(qb.Raw(")
			buf.WriteString(strconv.Quote(ac.GrantSubject))
			buf.WriteString("))")
		}
		if ac.GrantToken != "" {
			buf.WriteString(".Token(qb.Raw(")
			buf.WriteString(strconv.Quote(ac.GrantToken))
			buf.WriteString("))")
		}
		if ac.GrantDuration != "" {
			buf.WriteString(".Duration(qb.Raw(")
			buf.WriteString(strconv.Quote(ac.GrantDuration))
			buf.WriteString("))")
		}
		buf.WriteString(")\n")
	}
}

func renderFieldResource(buf *bytes.Buffer, model Model, field Field) {
	buf.WriteString("\tres.AddField(\"")
	buf.WriteString(model.Table)
	buf.WriteString("\", \"")
	buf.WriteString(field.DBName)
	buf.WriteString("\", ")
	buf.WriteString("qb.DefineFieldName(\"")
	buf.WriteString(field.DBName)
	buf.WriteString("\", \"")
	buf.WriteString(model.Table)
	buf.WriteString("\")")

	if t := inferSurrealType(field.Type, field, model); t != "" {
		buf.WriteString(".Type(\"")
		buf.WriteString(t)
		buf.WriteString("\")")
	}
	if field.ValueExpr != "" {
		buf.WriteString(".ValueExpr(qb.Raw(")
		buf.WriteString(strconv.Quote(field.ValueExpr))
		buf.WriteString("))")
	}
	if field.AssertExpr != "" {
		buf.WriteString(".Assert(qb.RawCond(")
		buf.WriteString(strconv.Quote(field.AssertExpr))
		buf.WriteString("))")
	}
	if field.DefaultExpr != "" {
		buf.WriteString(".DefaultExpr(qb.Raw(")
		buf.WriteString(strconv.Quote(field.DefaultExpr))
		buf.WriteString("))")
	}
	if field.Permissions != "" {
		writePermissions(buf, field.Permissions)
	}
	buf.WriteString(")\n")
}

func writePermissions(buf *bytes.Buffer, value string) {
	lower := strings.ToLower(strings.TrimSpace(value))
	switch lower {
	case "full":
		buf.WriteString(".PermissionsFull()")
	case "none":
		buf.WriteString(".PermissionsNone()")
	default:
		buf.WriteString(".PermissionsFor(qb.Raw(")
		buf.WriteString(strconv.Quote(value))
		buf.WriteString("))")
	}
}
